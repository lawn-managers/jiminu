# <a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AY9QUhl6cfQDFAVF&categoryId=AY9QUhl6cfQDFAVF&categoryType=CODE&problemTitle=&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1" title="문제" target="_blank">문제</a>

N (1≤N≤500)개의 상자와, 이 상자들을 넣을 수 있는 N+1개의 칸으로 구성된 보관함이 있다. 보관함의 모든 칸은 일렬로 놓여 있으며, 각 칸에는 최대 1개의 박스가 들어갈 수 있다. 편의상 각 상자에 1 이상 N 이하의 자연수 번호를 붙이고, 보관함의 각 칸에 맨 왼쪽 칸부터 순서대로 1,2,⋯,N+1의 번호를 붙이자. 맨 처음에는 N+1번 칸(맨 오른쪽 칸)은 비어 있고, 모든 1≤i≤N에 대해 i번 칸에 a_i번 상자가 들어 있다.
당신은 모든 1≤j≤N에 대해 j번 상자가 j번 칸에 들어 있도록 하기를 원한다. 이를 위해 당신은 상자가 들어 있는 보관함 칸을 하나 골라, 그 칸에 들어 있는 상자를 현재 비어 있는 칸으로 옮기는 작업을 최대 1500번 반복할 수 있다. 이러한 방법을 아무거나 하나 구하는 프로그램을 작성하라. (항상 가능함을 증명할 수 있다.)

# 입력
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 상자의 개수 N (1≤N≤500)이 주어진다. 두 번째 줄에는 N개의 정수 a_1,a_2,⋯,a_N이 공백 하나를 사이로 두고 주어진다. a_1,a_2,⋯,a_N은 1,2,⋯,N의 순열이다.

# 출력
각 테스트 케이스마다, 작업 횟수를 K라고 할 때: 첫 번째 줄에 K (0≤K≤1,500)를 출력한다.


# 출력 예제 설명
첫 번째 예제: 이미 목표가 달성되어 있다.
두 번째 예제: 각 작업 이후 보관함의 각 칸에 들어 있는 상자의 번호를 나열하면 다음과 같다. (X는 빈 칸을 의미한다.)
-    최초: [2, 3, 4, 1, X]
-    1번째 작업 이후: [2, 3, X, 1, 4]
-    2번째 작업 이후: [2, X, 3, 1, 4]
-    3번째 작업 이후: [X, 2, 3, 1, 4]
-    4번째 작업 이후: [1, 2, 3, X, 4]
5번째 작업 이후: [1, 2, 3, 4, X]

다음 줄에는 K개의 정수를 공백 하나를 사이로 두고 출력한다.
이 중 k (1≤k≤K)번째 정수는, k번째 작업에서 비어 있는 칸으로 옮길 상자가 들어 있는 보관함 칸의 번호여야 한다. 상자의 번호가 아니라, 칸의 번호라는 것에 유의하라.

입력
```
2
3
1 2 3
4
2 3 4 1
```

출력
```
0

5
3 2 1 4 5
```